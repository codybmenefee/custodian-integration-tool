"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/utils/globalErrorHandler.ts":
/*!*****************************************!*\
  !*** ./src/utils/globalErrorHandler.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleGlobalError: () => (/* binding */ handleGlobalError),\n/* harmony export */   initializeErrorMonitoring: () => (/* binding */ initializeErrorMonitoring),\n/* harmony export */   initializeGlobalErrorHandlers: () => (/* binding */ initializeGlobalErrorHandlers),\n/* harmony export */   isOnline: () => (/* binding */ isOnline),\n/* harmony export */   loadQueuedErrors: () => (/* binding */ loadQueuedErrors),\n/* harmony export */   monitorNetworkConnectivity: () => (/* binding */ monitorNetworkConnectivity),\n/* harmony export */   registerGlobalErrorHandler: () => (/* binding */ registerGlobalErrorHandler)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/../node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Global error handler for unhandled exceptions and rejections\n * Integrated with error monitoring services like Sentry\n */ // Import Sentry types if available, otherwise define minimal needed types\n// Available handlers\nconst handlers = [];\n/**\n * Initialize global error handlers for the application\n * Should be called once at application startup\n */ function initializeGlobalErrorHandlers() {\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event)=>{\n        const error = event.reason instanceof Error ? event.reason : new Error(String(event.reason));\n        handleGlobalError(error, 'Unhandled Promise Rejection');\n    });\n    // Handle uncaught exceptions\n    window.addEventListener('error', (event)=>{\n        handleGlobalError(event.error || new Error(event.message), 'Uncaught Exception');\n        // Prevent default browser error handling\n        event.preventDefault();\n    });\n    // Log initialization\n    console.info('Global error handlers initialized');\n}\n/**\n * Handle a global error by passing it to all registered handlers\n * @param error The error object\n * @param info Additional information about the error context\n */ function handleGlobalError(error, info) {\n    console.error(\"Global Error (\".concat(info, \"):\"), error);\n    // Call all registered handlers\n    handlers.forEach((handler)=>{\n        try {\n            handler(error, info);\n        } catch (handlerError) {\n            // Don't let handler errors crash the application\n            console.error('Error in error handler:', handlerError);\n        }\n    });\n}\n// Expose the handleGlobalError function for testing\nif (false) {}\n/**\n * Register a new error handler to process global errors\n * @param handler The handler function to register\n * @returns A function to unregister the handler\n */ function registerGlobalErrorHandler(handler) {\n    handlers.push(handler);\n    // Return function to unregister the handler\n    return ()=>{\n        const index = handlers.indexOf(handler);\n        if (index !== -1) {\n            handlers.splice(index, 1);\n        }\n    };\n}\n/**\n * Check if the application is currently online\n * @returns True if the application has network connectivity\n */ function isOnline() {\n    return typeof navigator !== 'undefined' && navigator.onLine;\n}\n/**\n * Monitor network connectivity and trigger handlers when status changes\n * @param onOffline Function to call when app goes offline\n * @param onOnline Function to call when app comes back online\n * @returns Function to stop monitoring\n */ function monitorNetworkConnectivity(onOffline, onOnline) {\n    const handleOffline = ()=>{\n        console.warn('Network connection lost');\n        if (onOffline) onOffline();\n    };\n    const handleOnline = ()=>{\n        console.info('Network connection restored');\n        if (onOnline) onOnline();\n    };\n    window.addEventListener('offline', handleOffline);\n    window.addEventListener('online', handleOnline);\n    // Return cleanup function\n    return ()=>{\n        window.removeEventListener('offline', handleOffline);\n        window.removeEventListener('online', handleOnline);\n    };\n}\nconst errorQueue = [];\n/**\n * Add an error to the offline queue\n * @param error The error event to queue\n */ function addToErrorQueue(error) {\n    errorQueue.push({\n        error,\n        timestamp: Date.now()\n    });\n    // Cap the queue size to prevent memory issues\n    if (errorQueue.length > 100) {\n        errorQueue.shift();\n    }\n    // Persist queue to localStorage if available\n    try {\n        localStorage.setItem('errorQueue', JSON.stringify(errorQueue));\n    } catch (e) {\n        console.error('Failed to persist error queue:', e);\n    }\n}\n/**\n * Process queued errors when back online\n */ function processErrorQueue() {\n    if (errorQueue.length === 0) return;\n    // Load Sentry dynamically\n    loadSentry().then((Sentry)=>{\n        console.info(\"Processing \".concat(errorQueue.length, \" queued errors\"));\n        // Process errors with rate limiting\n        const processNext = function() {\n            let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n            if (index >= errorQueue.length) {\n                // All processed, clear queue\n                errorQueue.length = 0;\n                try {\n                    localStorage.removeItem('errorQueue');\n                } catch (e) {\n                    console.error('Failed to clear error queue from storage:', e);\n                }\n                return;\n            }\n            const { error } = errorQueue[index];\n            Sentry.captureEvent(error);\n            // Process next with slight delay to avoid overwhelming the API\n            setTimeout(()=>processNext(index + 1), 100);\n        };\n        processNext();\n    }).catch((err)=>{\n        console.error('Failed to process error queue:', err);\n    });\n}\n/**\n * Load queued errors from localStorage on startup\n */ function loadQueuedErrors() {\n    try {\n        const storedQueue = localStorage.getItem('errorQueue');\n        if (storedQueue) {\n            const parsedQueue = JSON.parse(storedQueue);\n            errorQueue.push(...parsedQueue);\n            console.info(\"Loaded \".concat(parsedQueue.length, \" errors from queue\"));\n        }\n    } catch (e) {\n        console.error('Failed to load error queue:', e);\n    }\n}\n/**\n * Dynamically load Sentry to avoid bundling it unnecessarily\n * @returns A promise that resolves to the Sentry API\n */ async function loadSentry() {\n    try {\n        const Sentry = await Promise.resolve().then(function webpackMissingModule() { var e = new Error(\"Cannot find module '@sentry/browser'\"); e.code = 'MODULE_NOT_FOUND'; throw e; });\n        return Sentry;\n    } catch (error) {\n        console.error('Failed to load Sentry:', error);\n        throw error;\n    }\n}\n/**\n * Integration with Sentry error monitoring service\n */ function initializeErrorMonitoring() {\n    // Skip in development or test environments if desired\n    if ( true && !process.env.ENABLE_ERROR_MONITORING_IN_DEV) {\n        console.info('Error monitoring disabled in development mode');\n        return;\n    }\n    // Load Sentry dynamically\n    loadSentry().then((Sentry)=>{\n        Sentry.init({\n            dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,\n            environment: \"development\",\n            tracesSampleRate: 1.0,\n            // Only capture a percentage of sessions in production for performance\n            replaysSessionSampleRate:  false ? 0 : 1.0,\n            // But always capture sessions with errors\n            replaysOnErrorSampleRate: 1.0,\n            // Add more context to errors\n            beforeSend (event) {\n                // Don't send events when offline\n                if (!isOnline()) {\n                    // Queue the event for later sending\n                    addToErrorQueue(event);\n                    return null;\n                }\n                // Add additional context\n                if (event.user) {\n                    // Anonymize user IPs in certain environments\n                    if (process.env.ANONYMIZE_IPS) {\n                        event.user.ip_address = '0.0.0.0';\n                    }\n                }\n                return event;\n            }\n        });\n        // Register a global handler that reports to Sentry\n        registerGlobalErrorHandler((error, info)=>{\n            Sentry.captureException(error, {\n                extra: {\n                    info\n                }\n            });\n        });\n        // Set up network connectivity monitoring\n        monitorNetworkConnectivity(// When going offline, use a breadcrumb\n        ()=>{\n            Sentry.addBreadcrumb({\n                category: 'network',\n                message: 'Network connectivity lost',\n                level: 'warning'\n            });\n        }, // When coming back online, send queued errors\n        ()=>{\n            Sentry.addBreadcrumb({\n                category: 'network',\n                message: 'Network connectivity restored',\n                level: 'info'\n            });\n            processErrorQueue();\n        });\n        console.info('Sentry error monitoring initialized');\n    }).catch((err)=>{\n        console.error('Failed to initialize Sentry:', err);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9nbG9iYWxFcnJvckhhbmRsZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFRCwwRUFBMEU7QUFxQzFFLHFCQUFxQjtBQUNyQixNQUFNQSxXQUEyQixFQUFFO0FBRW5DOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2Qsc0NBQXNDO0lBQ3RDQyxPQUFPQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBQ0M7UUFDN0MsTUFBTUMsUUFBUUQsTUFBTUUsTUFBTSxZQUFZQyxRQUNsQ0gsTUFBTUUsTUFBTSxHQUNaLElBQUlDLE1BQU1DLE9BQU9KLE1BQU1FLE1BQU07UUFFakNHLGtCQUFrQkosT0FBTztJQUMzQjtJQUVBLDZCQUE2QjtJQUM3QkgsT0FBT0MsZ0JBQWdCLENBQUMsU0FBUyxDQUFDQztRQUNoQ0ssa0JBQWtCTCxNQUFNQyxLQUFLLElBQUksSUFBSUUsTUFBTUgsTUFBTU0sT0FBTyxHQUFHO1FBRTNELHlDQUF5QztRQUN6Q04sTUFBTU8sY0FBYztJQUN0QjtJQUVBLHFCQUFxQjtJQUNyQkMsUUFBUUMsSUFBSSxDQUFDO0FBQ2Y7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0osa0JBQWtCSixLQUFZLEVBQUVRLElBQVk7SUFDMURELFFBQVFQLEtBQUssQ0FBQyxpQkFBc0IsT0FBTFEsTUFBSyxPQUFLUjtJQUV6QywrQkFBK0I7SUFDL0JMLFNBQVNjLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDZixJQUFJO1lBQ0ZBLFFBQVFWLE9BQU9RO1FBQ2pCLEVBQUUsT0FBT0csY0FBYztZQUNyQixpREFBaUQ7WUFDakRKLFFBQVFQLEtBQUssQ0FBQywyQkFBMkJXO1FBQzNDO0lBQ0Y7QUFDRjtBQUVBLG9EQUFvRDtBQUNwRCxJQUFJQyxLQUErQixFQUFFLEVBRXBDO0FBRUQ7Ozs7Q0FJQyxHQUNNLFNBQVNHLDJCQUEyQkwsT0FBcUI7SUFDOURmLFNBQVNxQixJQUFJLENBQUNOO0lBRWQsNENBQTRDO0lBQzVD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QVM7Z0JBQ1RzRSxPQUFPO1lBQ1Q7UUFDRixHQUNBLDhDQUE4QztRQUM5QztZQUNFOUIsT0FBTzRCLGFBQWEsQ0FBQztnQkFDbkJDLFVBQVU7Z0JBQ1ZyRSxTQUFTO2dCQUNUc0UsT0FBTztZQUNUO1lBQ0FqQztRQUNGO1FBR0ZuQyxRQUFRQyxJQUFJLENBQUM7SUFDZixHQUFHMEMsS0FBSyxDQUFDQyxDQUFBQTtRQUNQNUMsUUFBUVAsS0FBSyxDQUFDLGdDQUFnQ21EO0lBQ2hEO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jb2R5bWVuZWZlZS9EZXNrdG9wL1Byb2plY3RzL2N1c3RvZGlhbkRlbW8vY2xpZW50L3NyYy91dGlscy9nbG9iYWxFcnJvckhhbmRsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHbG9iYWwgZXJyb3IgaGFuZGxlciBmb3IgdW5oYW5kbGVkIGV4Y2VwdGlvbnMgYW5kIHJlamVjdGlvbnNcbiAqIEludGVncmF0ZWQgd2l0aCBlcnJvciBtb25pdG9yaW5nIHNlcnZpY2VzIGxpa2UgU2VudHJ5XG4gKi9cblxuLy8gSW1wb3J0IFNlbnRyeSB0eXBlcyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBkZWZpbmUgbWluaW1hbCBuZWVkZWQgdHlwZXNcbmludGVyZmFjZSBTZW50cnlFdmVudCB7XG4gIHVzZXI/OiB7XG4gICAgaXBfYWRkcmVzcz86IHN0cmluZztcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIH07XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuaW50ZXJmYWNlIFNlbnRyeUJyZWFkY3J1bWJPcHRpb25zIHtcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBsZXZlbDogJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJyB8ICdmYXRhbCc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuaW50ZXJmYWNlIFNlbnRyeUluaXRPcHRpb25zIHtcbiAgZHNuPzogc3RyaW5nO1xuICBlbnZpcm9ubWVudD86IHN0cmluZztcbiAgdHJhY2VzU2FtcGxlUmF0ZT86IG51bWJlcjtcbiAgcmVwbGF5c1Nlc3Npb25TYW1wbGVSYXRlPzogbnVtYmVyO1xuICByZXBsYXlzT25FcnJvclNhbXBsZVJhdGU/OiBudW1iZXI7XG4gIGJlZm9yZVNlbmQ/OiAoZXZlbnQ6IFNlbnRyeUV2ZW50KSA9PiBTZW50cnlFdmVudCB8IG51bGw7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuLy8gRGVmaW5lIGEgbWluaW1hbCBTZW50cnkgaW50ZXJmYWNlIGZvciBvdXIgdXNhZ2VcbmludGVyZmFjZSBTZW50cnlBcGkge1xuICBpbml0KG9wdGlvbnM6IFNlbnRyeUluaXRPcHRpb25zKTogdm9pZDtcbiAgY2FwdHVyZUV4Y2VwdGlvbihlcnJvcjogRXJyb3IsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogc3RyaW5nO1xuICBjYXB0dXJlRXZlbnQoZXZlbnQ6IFNlbnRyeUV2ZW50KTogc3RyaW5nO1xuICBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWI6IFNlbnRyeUJyZWFkY3J1bWJPcHRpb25zKTogdm9pZDtcbn1cblxuLy8gVHlwZSBmb3IgZXJyb3IgaGFuZGxlciBmdW5jdGlvblxudHlwZSBFcnJvckhhbmRsZXIgPSAoZXJyb3I6IEVycm9yLCBpbmZvPzogc3RyaW5nKSA9PiB2b2lkO1xuXG4vLyBBdmFpbGFibGUgaGFuZGxlcnNcbmNvbnN0IGhhbmRsZXJzOiBFcnJvckhhbmRsZXJbXSA9IFtdO1xuXG4vKipcbiAqIEluaXRpYWxpemUgZ2xvYmFsIGVycm9yIGhhbmRsZXJzIGZvciB0aGUgYXBwbGljYXRpb25cbiAqIFNob3VsZCBiZSBjYWxsZWQgb25jZSBhdCBhcHBsaWNhdGlvbiBzdGFydHVwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplR2xvYmFsRXJyb3JIYW5kbGVycygpOiB2b2lkIHtcbiAgLy8gSGFuZGxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIChldmVudDogUHJvbWlzZVJlamVjdGlvbkV2ZW50KSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBldmVudC5yZWFzb24gaW5zdGFuY2VvZiBFcnJvciBcbiAgICAgID8gZXZlbnQucmVhc29uIFxuICAgICAgOiBuZXcgRXJyb3IoU3RyaW5nKGV2ZW50LnJlYXNvbikpO1xuICAgIFxuICAgIGhhbmRsZUdsb2JhbEVycm9yKGVycm9yLCAnVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uJyk7XG4gIH0pO1xuXG4gIC8vIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudDogRXJyb3JFdmVudCkgPT4ge1xuICAgIGhhbmRsZUdsb2JhbEVycm9yKGV2ZW50LmVycm9yIHx8IG5ldyBFcnJvcihldmVudC5tZXNzYWdlKSwgJ1VuY2F1Z2h0IEV4Y2VwdGlvbicpO1xuICAgIFxuICAgIC8vIFByZXZlbnQgZGVmYXVsdCBicm93c2VyIGVycm9yIGhhbmRsaW5nXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG5cbiAgLy8gTG9nIGluaXRpYWxpemF0aW9uXG4gIGNvbnNvbGUuaW5mbygnR2xvYmFsIGVycm9yIGhhbmRsZXJzIGluaXRpYWxpemVkJyk7XG59XG5cbi8qKlxuICogSGFuZGxlIGEgZ2xvYmFsIGVycm9yIGJ5IHBhc3NpbmcgaXQgdG8gYWxsIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gaW5mbyBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvciBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVHbG9iYWxFcnJvcihlcnJvcjogRXJyb3IsIGluZm86IHN0cmluZyk6IHZvaWQge1xuICBjb25zb2xlLmVycm9yKGBHbG9iYWwgRXJyb3IgKCR7aW5mb30pOmAsIGVycm9yKTtcbiAgXG4gIC8vIENhbGwgYWxsIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICB0cnkge1xuICAgICAgaGFuZGxlcihlcnJvciwgaW5mbyk7XG4gICAgfSBjYXRjaCAoaGFuZGxlckVycm9yKSB7XG4gICAgICAvLyBEb24ndCBsZXQgaGFuZGxlciBlcnJvcnMgY3Jhc2ggdGhlIGFwcGxpY2F0aW9uXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBoYW5kbGVyOicsIGhhbmRsZXJFcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gRXhwb3NlIHRoZSBoYW5kbGVHbG9iYWxFcnJvciBmdW5jdGlvbiBmb3IgdGVzdGluZ1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgKGdsb2JhbFRoaXMgYXMgYW55KS5fX3Rlc3RfaGFuZGxlR2xvYmFsRXJyb3IgPSBoYW5kbGVHbG9iYWxFcnJvcjtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBlcnJvciBoYW5kbGVyIHRvIHByb2Nlc3MgZ2xvYmFsIGVycm9yc1xuICogQHBhcmFtIGhhbmRsZXIgVGhlIGhhbmRsZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXJcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdG8gdW5yZWdpc3RlciB0aGUgaGFuZGxlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWxFcnJvckhhbmRsZXIoaGFuZGxlcjogRXJyb3JIYW5kbGVyKTogKCkgPT4gdm9pZCB7XG4gIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gIFxuICAvLyBSZXR1cm4gZnVuY3Rpb24gdG8gdW5yZWdpc3RlciB0aGUgaGFuZGxlclxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYXBwbGljYXRpb24gaXMgY3VycmVudGx5IG9ubGluZVxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYXBwbGljYXRpb24gaGFzIG5ldHdvcmsgY29ubmVjdGl2aXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09ubGluZSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5vbkxpbmU7XG59XG5cbi8qKlxuICogTW9uaXRvciBuZXR3b3JrIGNvbm5lY3Rpdml0eSBhbmQgdHJpZ2dlciBoYW5kbGVycyB3aGVuIHN0YXR1cyBjaGFuZ2VzXG4gKiBAcGFyYW0gb25PZmZsaW5lIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhcHAgZ29lcyBvZmZsaW5lXG4gKiBAcGFyYW0gb25PbmxpbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFwcCBjb21lcyBiYWNrIG9ubGluZVxuICogQHJldHVybnMgRnVuY3Rpb24gdG8gc3RvcCBtb25pdG9yaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb25pdG9yTmV0d29ya0Nvbm5lY3Rpdml0eShcbiAgb25PZmZsaW5lPzogKCkgPT4gdm9pZCxcbiAgb25PbmxpbmU/OiAoKSA9PiB2b2lkXG4pOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgaGFuZGxlT2ZmbGluZSA9ICgpID0+IHtcbiAgICBjb25zb2xlLndhcm4oJ05ldHdvcmsgY29ubmVjdGlvbiBsb3N0Jyk7XG4gICAgaWYgKG9uT2ZmbGluZSkgb25PZmZsaW5lKCk7XG4gIH07XG4gIFxuICBjb25zdCBoYW5kbGVPbmxpbmUgPSAoKSA9PiB7XG4gICAgY29uc29sZS5pbmZvKCdOZXR3b3JrIGNvbm5lY3Rpb24gcmVzdG9yZWQnKTtcbiAgICBpZiAob25PbmxpbmUpIG9uT25saW5lKCk7XG4gIH07XG4gIFxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGhhbmRsZU9mZmxpbmUpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgaGFuZGxlT25saW5lKTtcbiAgXG4gIC8vIFJldHVybiBjbGVhbnVwIGZ1bmN0aW9uXG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBoYW5kbGVPZmZsaW5lKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgaGFuZGxlT25saW5lKTtcbiAgfTtcbn1cblxuLy8gU3RvcmUgZXJyb3JzIHdoZW4gb2ZmbGluZSB0byBzZW5kIHdoZW4gYmFjayBvbmxpbmVcbmludGVyZmFjZSBRdWV1ZWRFcnJvciB7XG4gIGVycm9yOiBTZW50cnlFdmVudDtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNvbnN0IGVycm9yUXVldWU6IFF1ZXVlZEVycm9yW10gPSBbXTtcblxuLyoqXG4gKiBBZGQgYW4gZXJyb3IgdG8gdGhlIG9mZmxpbmUgcXVldWVcbiAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3IgZXZlbnQgdG8gcXVldWVcbiAqL1xuZnVuY3Rpb24gYWRkVG9FcnJvclF1ZXVlKGVycm9yOiBTZW50cnlFdmVudCk6IHZvaWQge1xuICBlcnJvclF1ZXVlLnB1c2goe1xuICAgIGVycm9yLFxuICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICB9KTtcbiAgXG4gIC8vIENhcCB0aGUgcXVldWUgc2l6ZSB0byBwcmV2ZW50IG1lbW9yeSBpc3N1ZXNcbiAgaWYgKGVycm9yUXVldWUubGVuZ3RoID4gMTAwKSB7XG4gICAgZXJyb3JRdWV1ZS5zaGlmdCgpO1xuICB9XG4gIFxuICAvLyBQZXJzaXN0IHF1ZXVlIHRvIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZXJyb3JRdWV1ZScsIEpTT04uc3RyaW5naWZ5KGVycm9yUXVldWUpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwZXJzaXN0IGVycm9yIHF1ZXVlOicsIGUpO1xuICB9XG59XG5cbi8qKlxuICogUHJvY2VzcyBxdWV1ZWQgZXJyb3JzIHdoZW4gYmFjayBvbmxpbmVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0Vycm9yUXVldWUoKTogdm9pZCB7XG4gIGlmIChlcnJvclF1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBcbiAgLy8gTG9hZCBTZW50cnkgZHluYW1pY2FsbHlcbiAgbG9hZFNlbnRyeSgpLnRoZW4oU2VudHJ5ID0+IHtcbiAgICBjb25zb2xlLmluZm8oYFByb2Nlc3NpbmcgJHtlcnJvclF1ZXVlLmxlbmd0aH0gcXVldWVkIGVycm9yc2ApO1xuICAgIFxuICAgIC8vIFByb2Nlc3MgZXJyb3JzIHdpdGggcmF0ZSBsaW1pdGluZ1xuICAgIGNvbnN0IHByb2Nlc3NOZXh0ID0gKGluZGV4ID0gMCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID49IGVycm9yUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFsbCBwcm9jZXNzZWQsIGNsZWFyIHF1ZXVlXG4gICAgICAgIGVycm9yUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZXJyb3JRdWV1ZScpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsZWFyIGVycm9yIHF1ZXVlIGZyb20gc3RvcmFnZTonLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGVycm9yUXVldWVbaW5kZXhdO1xuICAgICAgU2VudHJ5LmNhcHR1cmVFdmVudChlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgbmV4dCB3aXRoIHNsaWdodCBkZWxheSB0byBhdm9pZCBvdmVyd2hlbG1pbmcgdGhlIEFQSVxuICAgICAgc2V0VGltZW91dCgoKSA9PiBwcm9jZXNzTmV4dChpbmRleCArIDEpLCAxMDApO1xuICAgIH07XG4gICAgXG4gICAgcHJvY2Vzc05leHQoKTtcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBlcnJvciBxdWV1ZTonLCBlcnIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBMb2FkIHF1ZXVlZCBlcnJvcnMgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gc3RhcnR1cFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZFF1ZXVlZEVycm9ycygpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdG9yZWRRdWV1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlcnJvclF1ZXVlJyk7XG4gICAgaWYgKHN0b3JlZFF1ZXVlKSB7XG4gICAgICBjb25zdCBwYXJzZWRRdWV1ZSA9IEpTT04ucGFyc2Uoc3RvcmVkUXVldWUpO1xuICAgICAgZXJyb3JRdWV1ZS5wdXNoKC4uLnBhcnNlZFF1ZXVlKTtcbiAgICAgIGNvbnNvbGUuaW5mbyhgTG9hZGVkICR7cGFyc2VkUXVldWUubGVuZ3RofSBlcnJvcnMgZnJvbSBxdWV1ZWApO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGVycm9yIHF1ZXVlOicsIGUpO1xuICB9XG59XG5cbi8qKlxuICogRHluYW1pY2FsbHkgbG9hZCBTZW50cnkgdG8gYXZvaWQgYnVuZGxpbmcgaXQgdW5uZWNlc3NhcmlseVxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFNlbnRyeSBBUElcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZFNlbnRyeSgpOiBQcm9taXNlPFNlbnRyeUFwaT4ge1xuICB0cnkge1xuICAgIGNvbnN0IFNlbnRyeSA9IGF3YWl0IGltcG9ydCgnQHNlbnRyeS9icm93c2VyJyk7XG4gICAgcmV0dXJuIFNlbnRyeSBhcyB1bmtub3duIGFzIFNlbnRyeUFwaTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBTZW50cnk6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogSW50ZWdyYXRpb24gd2l0aCBTZW50cnkgZXJyb3IgbW9uaXRvcmluZyBzZXJ2aWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JNb25pdG9yaW5nKCk6IHZvaWQge1xuICAvLyBTa2lwIGluIGRldmVsb3BtZW50IG9yIHRlc3QgZW52aXJvbm1lbnRzIGlmIGRlc2lyZWRcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFwcm9jZXNzLmVudi5FTkFCTEVfRVJST1JfTU9OSVRPUklOR19JTl9ERVYpIHtcbiAgICBjb25zb2xlLmluZm8oJ0Vycm9yIG1vbml0b3JpbmcgZGlzYWJsZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZScpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgLy8gTG9hZCBTZW50cnkgZHluYW1pY2FsbHlcbiAgbG9hZFNlbnRyeSgpLnRoZW4oU2VudHJ5ID0+IHtcbiAgICBTZW50cnkuaW5pdCh7XG4gICAgICBkc246IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NFTlRSWV9EU04sXG4gICAgICBlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXG4gICAgICB0cmFjZXNTYW1wbGVSYXRlOiAxLjAsXG4gICAgICAvLyBPbmx5IGNhcHR1cmUgYSBwZXJjZW50YWdlIG9mIHNlc3Npb25zIGluIHByb2R1Y3Rpb24gZm9yIHBlcmZvcm1hbmNlXG4gICAgICByZXBsYXlzU2Vzc2lvblNhbXBsZVJhdGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAwLjEgOiAxLjAsXG4gICAgICAvLyBCdXQgYWx3YXlzIGNhcHR1cmUgc2Vzc2lvbnMgd2l0aCBlcnJvcnNcbiAgICAgIHJlcGxheXNPbkVycm9yU2FtcGxlUmF0ZTogMS4wLFxuICAgICAgLy8gQWRkIG1vcmUgY29udGV4dCB0byBlcnJvcnNcbiAgICAgIGJlZm9yZVNlbmQoZXZlbnQpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc2VuZCBldmVudHMgd2hlbiBvZmZsaW5lXG4gICAgICAgIGlmICghaXNPbmxpbmUoKSkge1xuICAgICAgICAgIC8vIFF1ZXVlIHRoZSBldmVudCBmb3IgbGF0ZXIgc2VuZGluZ1xuICAgICAgICAgIGFkZFRvRXJyb3JRdWV1ZShldmVudCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIGNvbnRleHRcbiAgICAgICAgaWYgKGV2ZW50LnVzZXIpIHtcbiAgICAgICAgICAvLyBBbm9ueW1pemUgdXNlciBJUHMgaW4gY2VydGFpbiBlbnZpcm9ubWVudHNcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuQU5PTllNSVpFX0lQUykge1xuICAgICAgICAgICAgZXZlbnQudXNlci5pcF9hZGRyZXNzID0gJzAuMC4wLjAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFJlZ2lzdGVyIGEgZ2xvYmFsIGhhbmRsZXIgdGhhdCByZXBvcnRzIHRvIFNlbnRyeVxuICAgIHJlZ2lzdGVyR2xvYmFsRXJyb3JIYW5kbGVyKChlcnJvciwgaW5mbykgPT4ge1xuICAgICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oZXJyb3IsIHtcbiAgICAgICAgZXh0cmE6IHsgaW5mbyB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFNldCB1cCBuZXR3b3JrIGNvbm5lY3Rpdml0eSBtb25pdG9yaW5nXG4gICAgbW9uaXRvck5ldHdvcmtDb25uZWN0aXZpdHkoXG4gICAgICAvLyBXaGVuIGdvaW5nIG9mZmxpbmUsIHVzZSBhIGJyZWFkY3J1bWJcbiAgICAgICgpID0+IHtcbiAgICAgICAgU2VudHJ5LmFkZEJyZWFkY3J1bWIoe1xuICAgICAgICAgIGNhdGVnb3J5OiAnbmV0d29yaycsXG4gICAgICAgICAgbWVzc2FnZTogJ05ldHdvcmsgY29ubmVjdGl2aXR5IGxvc3QnLFxuICAgICAgICAgIGxldmVsOiAnd2FybmluZydcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gV2hlbiBjb21pbmcgYmFjayBvbmxpbmUsIHNlbmQgcXVldWVkIGVycm9yc1xuICAgICAgKCkgPT4ge1xuICAgICAgICBTZW50cnkuYWRkQnJlYWRjcnVtYih7XG4gICAgICAgICAgY2F0ZWdvcnk6ICduZXR3b3JrJyxcbiAgICAgICAgICBtZXNzYWdlOiAnTmV0d29yayBjb25uZWN0aXZpdHkgcmVzdG9yZWQnLFxuICAgICAgICAgIGxldmVsOiAnaW5mbydcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NFcnJvclF1ZXVlKCk7XG4gICAgICB9XG4gICAgKTtcbiAgICBcbiAgICBjb25zb2xlLmluZm8oJ1NlbnRyeSBlcnJvciBtb25pdG9yaW5nIGluaXRpYWxpemVkJyk7XG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU2VudHJ5OicsIGVycik7XG4gIH0pO1xufSAiXSwibmFtZXMiOlsiaGFuZGxlcnMiLCJpbml0aWFsaXplR2xvYmFsRXJyb3JIYW5kbGVycyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImVycm9yIiwicmVhc29uIiwiRXJyb3IiLCJTdHJpbmciLCJoYW5kbGVHbG9iYWxFcnJvciIsIm1lc3NhZ2UiLCJwcmV2ZW50RGVmYXVsdCIsImNvbnNvbGUiLCJpbmZvIiwiZm9yRWFjaCIsImhhbmRsZXIiLCJoYW5kbGVyRXJyb3IiLCJwcm9jZXNzIiwiZ2xvYmFsVGhpcyIsIl9fdGVzdF9oYW5kbGVHbG9iYWxFcnJvciIsInJlZ2lzdGVyR2xvYmFsRXJyb3JIYW5kbGVyIiwicHVzaCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImlzT25saW5lIiwibmF2aWdhdG9yIiwib25MaW5lIiwibW9uaXRvck5ldHdvcmtDb25uZWN0aXZpdHkiLCJvbk9mZmxpbmUiLCJvbk9ubGluZSIsImhhbmRsZU9mZmxpbmUiLCJ3YXJuIiwiaGFuZGxlT25saW5lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImVycm9yUXVldWUiLCJhZGRUb0Vycm9yUXVldWUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwibGVuZ3RoIiwic2hpZnQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImUiLCJwcm9jZXNzRXJyb3JRdWV1ZSIsImxvYWRTZW50cnkiLCJ0aGVuIiwiU2VudHJ5IiwicHJvY2Vzc05leHQiLCJyZW1vdmVJdGVtIiwiY2FwdHVyZUV2ZW50Iiwic2V0VGltZW91dCIsImNhdGNoIiwiZXJyIiwibG9hZFF1ZXVlZEVycm9ycyIsInN0b3JlZFF1ZXVlIiwiZ2V0SXRlbSIsInBhcnNlZFF1ZXVlIiwicGFyc2UiLCJpbml0aWFsaXplRXJyb3JNb25pdG9yaW5nIiwiZW52IiwiRU5BQkxFX0VSUk9SX01PTklUT1JJTkdfSU5fREVWIiwiaW5pdCIsImRzbiIsIk5FWFRfUFVCTElDX1NFTlRSWV9EU04iLCJlbnZpcm9ubWVudCIsInRyYWNlc1NhbXBsZVJhdGUiLCJyZXBsYXlzU2Vzc2lvblNhbXBsZVJhdGUiLCJyZXBsYXlzT25FcnJvclNhbXBsZVJhdGUiLCJiZWZvcmVTZW5kIiwidXNlciIsIkFOT05ZTUlaRV9JUFMiLCJpcF9hZGRyZXNzIiwiY2FwdHVyZUV4Y2VwdGlvbiIsImV4dHJhIiwiYWRkQnJlYWRjcnVtYiIsImNhdGVnb3J5IiwibGV2ZWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/globalErrorHandler.ts\n"));

/***/ })

});